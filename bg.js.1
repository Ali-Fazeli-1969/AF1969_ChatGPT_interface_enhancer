let storage;
let win;
let mirrorTabIdsArray;

browser.runtime.onMessage.addListener(async (message, sender) => {
	switch (message.type) {
		case "create_mirror":
			win = await browser.windows.create({
				url: message.chatUrl,
				type: "normal",
				width: 800,
				height: 600
			});
			await browser.storage.local.set({
				mirrorWindowId: win.id,
				mainTabId: sender.tab.id
			});
			break;

		case "check_if_mirror_window":
			win = await browser.windows.getCurrent();
			storage = await browser.storage.local.get(
							["mirrorWindowId", "mainTabId", "mirrorTabIds"]
					  );
			if (win.id === storage.mirrorWindowId) {
				mirrorTabIdsArray = storage.mirrorTabIds || [];
				mirrorTabIdsArray.push(sender.tab.id);
				await browser.storage.local.set({
					mirrorTabIds: mirrorTabIdsArray
				});
				return true;
			} else
				return false;
			break;

		case "mirror_tab_ready":
			storage = browser.storage.local.get("mainTabId");
			await browser.tabs.sendMessage(
				storage.mainTabId,
				{ type: "main_tab_send_chat" }
			);
			break;

		case "check_if_mirror_tab_exists":
			try {
				storage = await browser.storage.local.get("mirrorTabIds");
				for (let mirrorTabId of mirrorTabIds)
					await browser.tabs.get(mirrorTabId);
				return true;
			} catch {
				return false;
			}
			break;

		case "update_mirror_chat":
			storage = await browser.storage.local.get("mirrorTabIds");
			browser.scripting.executeScript({
				target: { tabId: storage.mirrorTabIds },
				func: (chatContent) => {
					const chatContainer = document.body;
					const scrollElementName =
						"div[class^='flex h-full flex-col overflow-y-auto']";
					let scrollElement =
						document.querySelector(scrollElementName);
					if (!scrollElement) {
						console.error("scrollElement not found");
						return false;
					}

					// save and restore the mirror tab
					// scroll position
					const scrollPosition = scrollElement.scrollTop;
					chatContainer.innerHTML = chatContent;
					// after injection the scroll element has to be reselected
					scrollElement = document.querySelector(scrollElementName);
					scrollElement.scrollTop = scrollPosition;
				},
				args: [message.content]
			});
			break;
	}
});

browser.tabs.onRemoved.addListener(async (tabId) => {
	storage = await browser.storage.local.get(
				["mainTabId", "mirrorTabIds"],
			 );
	if (
		!Array.isArray(storage.mirrorTabIds ||

	)
		return;
	else if (typeof mainTabId === "undefined")
		return
	mirrorTabIdsArray = storage.mirrorTabIds;
	const mainTabId = storage.mainTabId;
	if (
		typeof mainTabId === "undefined" ||
	    typeof mirrorTabIds === "undefined"
	) return;
	else if (mainTabId === tabId) {
		await browser.tabs.remove(mirrorTabIds);
		await browser.storage.local.remove(
			["mainTabId", "mirrorTabIds", "mirrorWindowId"]
		);
	} else if (mirrorTabIds === tabId) {
		await browser.tabs.sendMessage(
			mainTabId,
			{ type: "mirror_tab_closed" }
		);
		await browser.storage.local.remove("mirrorTabIds");
	}
});
